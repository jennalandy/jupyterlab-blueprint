import * as tslib_1 from "tslib";
import * as React from 'react';
import { concatStyleSets } from '@uifabric/merge-styles';
import { Customizations } from './Customizations';
import { CustomizerContext } from './Customizer';
var DefaultFields = ['theme', 'styles'];
/**
 * The styled HOC wrapper allows you to create a functional wrapper around a given component which will resolve
 * getStyles functional props, and mix customized props passed in using concatStyleSets.
 *
 * @example
 * ```tsx
 * export const Toggle = styled(
 *   ToggleBase,
 *   props => ({ root: { background: 'red' }})
 * );
 * ```
 * @param Component - The unstyled base component to render, which receives styles.
 * @param baseStyles - The styles which should be curried with the component.
 * @param getProps - A helper which provides default props.
 * @param customizable - An object which defines which props can be customized using the Customizer.
 */
export function styled(Component, baseStyles, getProps, customizable) {
    var Wrapped = function (componentProps) {
        customizable = customizable || { scope: '', fields: undefined };
        var scope = customizable.scope, _a = customizable.fields, fields = _a === void 0 ? DefaultFields : _a;
        return (React.createElement(CustomizerContext.Consumer, null, function (context) {
            var settings = Customizations.getSettings(fields, scope, context.customizations);
            var customizedStyles = settings.styles, rest = tslib_1.__rest(settings, ["styles"]);
            var styles = function (styleProps) { return _resolve(styleProps, baseStyles, customizedStyles, componentProps.styles); };
            var additionalProps = getProps ? getProps(componentProps) : undefined;
            return React.createElement(Component, tslib_1.__assign({}, rest, additionalProps, componentProps, { styles: styles }));
        }));
    };
    Wrapped.displayName = "Styled" + (Component.displayName || Component.name);
    return Wrapped;
}
function _resolve(styleProps) {
    var allStyles = [];
    for (var _i = 1; _i < arguments.length; _i++) {
        allStyles[_i - 1] = arguments[_i];
    }
    var result = [];
    for (var _a = 0, allStyles_1 = allStyles; _a < allStyles_1.length; _a++) {
        var styles = allStyles_1[_a];
        if (styles) {
            result.push(typeof styles === 'function' ? styles(styleProps) : styles);
        }
    }
    if (result.length) {
        // cliffkoh: I cannot figure out how to avoid the cast to any here.
        // It is something to do with the use of Omit in IStyleSet.
        // It might not be necessary once  Omit becomes part of lib.d.ts (when we remove our own Omit and rely on
        // the official version).
        // tslint:disable-next-line:no-any
        return concatStyleSets.apply(void 0, result);
    }
    return undefined;
}
//# sourceMappingURL=styled.js.map